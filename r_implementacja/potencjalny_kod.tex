\begin{lstlisting}[caption={Kod moduÅ‚u silnika przetwarzania wideo z zawartymi mechanizami synchronizacji}, label={lst:engine-1}]
    class VideoProcessingEngine:
        def __init__(self, video_capture: VideoCapture, image_processor: ImageProcessor, audio_alarm: App) -> None:
            # Obiekty implementujace metody potrzebne w podmodulach
            self._video_capture = video_capture
            self._image_processor = image_processor
            self._audio_alarm = audio_alarm
    
            self._frame_buffer = None # Bufor posredni
            self._processed_frame_buffer = None # Bufor wyjsciowy klatki
            self._is_capture_on = False # Okresla czy kamera dziala
    
            self._frame_set_lock = threading.Lock()
            self._video_capture_lock = threading.Lock()
            self._buffer_lock = threading.Lock()
            self._buffer_not_empty = threading.Condition(self._buffer_lock)
            self._capture_event = threading.Event()
            self._process_event = threading.Event()
    
            # Warunek petli podtrzymujacy istnienie watkow 
            # Jest ustawiany na False kiedy aplikacja zostaje wylaczona
            self._continue_thread_loop = True
    
            # Watek do podmodulu drugiego
            self._processing_thread = threading.Thread(target=self._process_frames, daemon=True)
            # Watek do podmodulu pierwszego
            self._capture_thread = threading.Thread(target=self._capture_frames, daemon=True)
    
            # Flagi kontrolujaca czy powtorzenia sekwencji podmodulow ... 
            # ... powinny byc kontynuowane badz wstrzymane
            self._capture_event.clear()
            self._process_event.clear()
    
    
        # Metoda sprawdzajaca czy bufor posredni jest pusty:
        def _is_buffer_empty(self) -> bool:
            return self._frame_buffer is None 
        
        # Metoda wstawiajaca klatke do bufora posredniego:
        def _set_buffer(self, frame: MatLike) -> None:
            self._frame_buffer = frame
        
        # Metoda pobierajaca klatke z bufora posredniego ... 
        # oraz go czyszczaca:
        def _fetch_buffer(self) -> MatLike|None:
            frame = self._frame_buffer
            self._frame_buffer = None
            return frame
    
        # Metoda wstawiajaca przygotowana klatke ... 
        # ... do bufora wyjsciowego:
        def _set_processed_frame_buffer(self, frame: MatLike) -> None:
            self._processed_frame_buffer = frame
    
        # Metoda pobierajaca klatke z bufora wyjsciowego ... 
        # oraz go czyszczaca:
        def _fetch_processed_frame_buffer(self) -> MatLike:
            frame = self._processed_frame_buffer
            self._processed_frame_buffer = None
    
            return frame
    
        # Metoda uruchamiajaca modul (wywolana przez App)
        def run(self) -> None:
            self._processing_thread.start()
            self._capture_thread.start()
    
        # Metoda implementujaca kroki podmodulu pierwszego:
        def _capture_frames(self) -> None:
            while self._continue_thread_loop:
                if not self._capture_event.is_set():
                    # Czekanie az kamera zostanie ustawiona:
                    self._capture_event.wait()
                    # Jezeli nastapilo wylaczenie aplikacji, zakoncz petle: 
                    if not self._continue_thread_loop:
                        return
    
                with self._video_capture_lock:
                    is_capture_on, frame = self._video_capture.get_frame()
    
                if not is_capture_on:
                    self.remove_video_source()
                    continue
    
                if frame is None:
                    continue
    
                frame = self._image_processor.fit_frame_into_screen(frame, self._max_frame_width, self._max_frame_height)
                
                with self._buffer_lock:
                    self._set_buffer(frame)
                    self._buffer_not_empty.notify()
    
    
        # Metoda implementujaca kroki podmodulu drugiego:
        def _process_frames(self) -> None:
            while self._continue_thread_loop:
                if not self._process_event.is_set():
                    self._process_event.wait()
                    # Jezeli nastapilo wylaczenie aplikacji, zakoncz petle:
                    if not self._continue_thread_loop:
                        return
    
                with self._buffer_not_empty:
                    while self._is_buffer_empty():
                        self._buffer_not_empty.wait()
                        # Jezeli nastapilo wylaczenie aplikacji, zakoncz petle:
                        if not self._continue_thread_loop:  
                            return
    
                    frame = self._fetch_buffer() 
    
                detections, are_there_objects = self._image_processor.detect_objects(frame)
                frame = self._image_processor.visualize_objects_presence(frame, detections)
    
                if are_there_objects:
                    self._audio_alarm.play_audio_alert()
           
                with self._frame_set_lock:
                    self._set_processed_frame_buffer(frame)
    
        # Metoda wywolywana periodycznie przez GUI ... 
        # ... za posrednictwem App ... 
        # w celu poboru gotowej klatki do wyswietlenia ... 
        # oraz informacji czy kamera dalej dziala
        def get_processed_frame(self) -> Tuple[bool, Optional[MatLike]]:
            with self._frame_set_lock:
                is_capture_on = self._is_capture_on
            frame = self._fetch_processed_frame_buffer()
            
            return is_capture_on, frame
    \end{lstlisting}